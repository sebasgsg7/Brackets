<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>üé≥ Bowling Brackets (layout cl√°sico con l√≠neas y cajas centradas)</title>
  <meta name="viewport" content="initial-scale=1" />
  <style>
    :root { --bg:#f5f7fb; --card:#fff; --muted:#64748b; --border:#e5e7eb; --primary:#2563eb; --ok:#16a34a; --warn:#b91c1c; --line:#cbd5e1; }
    *{ box-sizing:border-box }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:var(--bg); color:#0f172a }
    h1{ text-align:center; margin:20px 8px 4px }
    .wrap{ max-width:1200px; margin:0 auto; padding:16px }
    .row{ display:grid; grid-template-columns: 1fr 1fr; gap:16px }
    .card{ position:relative; background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; width:100% }
    textarea{ width:100%; height:160px; padding:10px; border-radius:10px; border:1px solid var(--border) }
    button{ padding:8px 12px; border-radius:10px; border:1px solid var(--border); background:#fff; cursor:pointer }
    button.primary{ background:var(--primary); color:#fff; border-color:var(--primary) }
    button.ghost{ background:#fff }
    button:disabled{ opacity:.6; cursor:not-allowed }
    table{ width:100%; border-collapse:collapse }
    th, td{ padding:8px; border-bottom:1px solid var(--border); text-align:left; font-size:14px }
    input[type="number"]{ width:90px; padding:6px; border:1px solid var(--border); border-radius:8px }
    .muted{ color:var(--muted); font-size:12px }
    .pill{ display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; font-size:12px; border:1px solid #e0e7ff }
    .grid-brackets{ display:flex; flex-direction:column; gap:16px; margin-top:16px }
    .btitle{ display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; gap:8px; flex-wrap:wrap }
    .colgrid{ display:grid; gap:0 } /* cada columna usa filas discretas */
    .roundtitle{ text-align:center; font-size:13px; color:#334155; font-weight:600; margin-bottom:6px }
    .match{ background:#fff; border:1px solid var(--border); border-radius:10px; padding:8px; min-height:64px; display:flex; flex-direction:column; justify-content:center }
    .rowPlayer{ display:flex; align-items:center; gap:8px; margin:6px 0 }
    .playerBtn{ flex:1; padding:8px; border:1px solid #cbd5e1; border-radius:8px; text-align:left; background:#fff; }
    .playerBtn.winner{ background:var(--ok); color:#fff; border-color:var(--ok) }
    .playerBtn.disabled{ background:#f1f5f9; color:#94a3b8; cursor:not-allowed }
    .score{ width:90px; padding:6px; border:1px solid #cbd5e1; border-radius:8px; text-align:right }
    .totalBadge{ min-width:80px; padding:6px 10px; border-radius:999px; border:1px solid var(--border); background:#f8fafc; font-size:12px; text-align:center }
    .sel{ flex:1; padding:6px; border:1px solid #cbd5e1; border-radius:8px; background:#fff }
    .hint{ font-size:12px; color:#475569 }
    .warn{ color:var(--warn); font-size:12px; margin-top:4px }
    .toolbar{ display:flex; gap:8px; flex-wrap:wrap; margin:8px 0 }
    .right{ text-align:right }
    .tbBox{ border:1px dashed #cbd5e1; border-radius:10px; padding:8px; margin-top:8px; background:#f9fafb }
    .tbTitle{ font-size:12px; color:#334155; margin-bottom:6px; font-weight:600 }
    .tbRow{ display:flex; align-items:center; gap:8px; margin:4px 0 }
    .tbBadge{ min-width:70px; padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:#eef2ff; font-size:12px; text-align:center }
    /* SVG enlaces */
    .links{ position:absolute; inset:0; pointer-events:none }
    @media (max-width: 900px){ .row{ grid-template-columns:1fr } }
    @media print{ .noprint{ display:none !important } body{ background:#fff } .wrap{ padding:0 } }
  </style>
</head>
<body>
  <h1>üé≥ Bowling Brackets</h1>
  <div class="wrap">
    <div class="row">
      <!-- Paso 1 -->
      <div class="card">
        <h3>1) Participantes base</h3>
        <p class="muted">Registre un jugador por l√≠nea. La <b>ventaja</b> se configura por jugador al momento de generar los brackets.</p>
        <textarea id="names" placeholder="Ejemplo:
Pedro Perez
Lucio Lopez
..."></textarea>
        <div class="toolbar">
          <button class="primary" id="btnSetup">Configurar participaciones‚Ä¶</button>
          <button class="ghost noprint" id="btnImport">Importar JSON</button>
          <button class="ghost noprint" id="btnClear">Limpiar</button>
        </div>
      </div>

      <!-- Paso 2 -->
      <div class="card" id="configCard" style="display:none">
        <h3>2) Cantidad de brackets y Ventaja por jugador</h3>
        <table id="tbl">
          <thead><tr><th>Jugador</th><th>Inscripciones</th><th>Ventaja</th></tr></thead>
          <tbody></tbody>
        </table>

        <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-top:8px">
          <div><span class="muted">Total inscripciones: </span><strong id="totalEntries">0</strong></div>
          <div><span class="muted">Brackets requeridos: </span><strong id="needed">0</strong></div>
        </div>

        <div class="toolbar">
          <button id="btnEven">1 a todos</button>
          <button id="btnZero">0 a todos</button>
          <span class="hint">Ventaja: entero ‚â• 0 (se suma al puntaje del jugador).</span>
        </div>

        <div class="toolbar">
          <button class="primary" id="btnGenerate">Generar brackets</button>
        </div>
        <p class="muted">Regla: <code>B = max( ceil(total/8), m√°ximo por jugador )</code>.</p>
      </div>
    </div>

    <!-- Salida -->
    <div id="out" class="grid-brackets"></div>
    <div class="toolbar noprint" style="justify-content:space-between">
      <div class="muted">Layout visual con cajas centradas y l√≠neas entre llaves. Desempate: menor ventaja; si igual, play-in.</div>
      <div class="right">
        <button id="btnExport">Exportar JSON</button>
        <button onclick="window.print()">Imprimir</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Utilidades =====
    const NBSP=/\u00A0/g;
    const normSpaces=s=>s.replace(NBSP,' ').replace(/\s+/g,' ').trim();
    const canon=s=>normSpaces((s??'')).toLowerCase();
    const uniq=arr=>Array.from(new Set(arr));
    function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
    function autoAdvance(a,b){ if(a&&!b) return a; if(!a&&b) return b; return null }
    function pairKey(a,b){ const A=canon(a),B=canon(b); return A<B?A+'|'+B:B+'|'+A }
    const toInt=v=>{ const n=parseInt(v,10); return Number.isFinite(n)&&n>=0?n:0 }

    // ===== Estado =====
    let players=[];           // nombres √∫nicos
    let wants={};             // { nombre -> inscripciones }
    let handicaps={};         // { nombre -> ventaja ‚â• 0 }
    let brackets=[];          // [{name, rounds}]
    let pairHistory=new Map();
    const BRACKET_SIZE=8;

    // ===== Parseo inicial =====
    function parsePlayersAndCounts(text){
      const map=new Map();
      const lines=text.split(/\n/).map(s=>s.trim()).filter(Boolean);
      for(const raw of lines){
        const line=normSpaces(raw);
        const m=line.match(/^(.*?)(?:\((\d+)\))\s*$/);
        let name,count=1;
        if(m){ name=normSpaces(m[1]); count=Math.max(0,parseInt(m[2],10)||0); }
        else{ name=line; }
        const key=canon(name); if(!key) continue;
        if(!map.has(key)) map.set(key,{name,count}); else map.get(key).count+=count;
      }
      if(map.size===0){
        const simple=uniq(lines.map(normSpaces).filter(Boolean));
        simple.forEach(n=>map.set(canon(n),{name:n,count:1}));
      }
      players=Array.from(map.values()).map(x=>x.name);
      wants={}; handicaps={};
      for(const {name,count} of map.values()){ wants[name]=count; handicaps[name]=0; }
    }

    // ===== UI Config =====
    document.getElementById('btnSetup').onclick=()=>{
      parsePlayersAndCounts(document.getElementById('names').value);
      if(!players.length){ alert('Ingresa al menos 1 nombre'); return; }
      renderConfigTable();
      document.getElementById('configCard').style.display='';
    };
    document.getElementById('btnClear').onclick=()=>{
      document.getElementById('names').value='';
      document.getElementById('configCard').style.display='none';
      document.querySelector('#tbl tbody').innerHTML='';
      document.getElementById('totalEntries').textContent='0';
      document.getElementById('needed').textContent='0';
      brackets=[]; pairHistory.clear(); document.getElementById('out').innerHTML='';
    };
    function renderConfigTable(){
      const tbody=document.querySelector('#tbl tbody'); tbody.innerHTML='';
      players.forEach(n=>{
        const tr=document.createElement('tr');

        const tdN=document.createElement('td'); tdN.textContent=n;

        const tdC=document.createElement('td');
        const inC=document.createElement('input');
        inC.type='number'; inC.min='0'; inC.step='1'; inC.value=wants[n]??1;
        inC.oninput=()=>{ wants[n]=Math.max(0,parseInt(inC.value||'0',10)); refreshTotals(); };
        tdC.appendChild(inC);

        const tdH=document.createElement('td');
        const inH=document.createElement('input');
        inH.type='number'; inH.min='0'; inH.step='1'; inH.value=Math.max(0, parseInt((handicaps[n]??0),10) || 0);
        inH.oninput=()=>{ const v=parseInt(inH.value,10); handicaps[n]=(!Number.isFinite(v)||v<0)?0:v; inH.value=String(handicaps[n]); };
        tdH.appendChild(inH);

        tr.appendChild(tdN); tr.appendChild(tdC); tr.appendChild(tdH);
        tbody.appendChild(tr);
      });
      refreshTotals();
    }
    function refreshTotals(){
      const vals=Object.values(wants).map(v=>v|0);
      const total=vals.reduce((a,b)=>a+b,0);
      const maxPerPlayer=Math.max(0,...vals);
      const B=Math.max(Math.ceil(total/BRACKET_SIZE), maxPerPlayer);
      document.getElementById('totalEntries').textContent=String(total);
      document.getElementById('needed').textContent=String(B);
    }
    document.getElementById('btnEven').onclick=()=>{ players.forEach(n=>wants[n]=1); renderConfigTable(); };
    document.getElementById('btnZero').onclick=()=>{ players.forEach(n=>wants[n]=0); renderConfigTable(); };

    // ===== Generaci√≥n (balanceada) + RESET =====
    document.getElementById('btnGenerate').onclick=()=>{
      // reset total
      brackets=[]; pairHistory=new Map(); document.getElementById('out').innerHTML='';

      // validar
      for(const n of players){ const h=parseInt(handicaps[n],10); if(!Number.isFinite(h)||h<0){ alert(`Ventaja inv√°lida para "${n}"`); return; } }
      const vals=Object.values(wants).map(v=>v|0);
      const total=vals.reduce((a,b)=>a+b,0);
      if(!total){ alert('No hay inscripciones'); return; }

      const maxPerPlayer=Math.max(0,...vals);
      const B=Math.max(Math.ceil(total/BRACKET_SIZE), maxPerPlayer);

      const buckets=Array.from({length:B},()=>[]);
      const remaining=Object.fromEntries(players.map(n=>[n,wants[n]|0]));
      let remainingTotal=total;

      while(remainingTotal>0){
        let placed=0;
        for(const n of players){
          if(remaining[n]<=0) continue;
          let best=-1,bestLen=1e9;
          for(let b=0;b<B;b++){
            if(buckets[b].length>=BRACKET_SIZE) continue;
            if(buckets[b].some(x=>canon(x)===canon(n))) continue;
            if(buckets[b].length<bestLen){ bestLen=buckets[b].length; best=b; }
          }
          if(best!==-1){ buckets[best].push(n); remaining[n]--; remainingTotal--; placed++; }
        }
        if(placed===0) break;
      }
      buckets.forEach(arr=>{ while(arr.length<BRACKET_SIZE) arr.push(null); });

      pairHistory.clear();
      brackets=buckets.map((arr,i)=>{
        const ordered=bestFirstRoundOrder(arr,pairHistory,500);
        return { name:`Bracket ${i+1}`, rounds: buildRoundsFromFirstRound(ordered) };
      });

      safeRenderAll();
    };

    function bestFirstRoundOrder(list,history,tries=300){
      const nonNull=list.filter(x=>x!==null);
      if(nonNull.length<=1) return list;
      let best=null,bestCost=1e9;
      for(let t=0;t<tries;t++){
        const perm=shuffle([...list]);
        let cost=0,ok=true;
        for(let i=0;i<perm.length;i+=2){
          const a=perm[i],b=perm[i+1]??null;
          if(!a||!b) continue;
          if(canon(a)===canon(b)){ cost+=1000; ok=false; break; }
          const key=pairKey(a,b); cost+=(history.get(key)|0);
        }
        if(ok&&cost<bestCost){ bestCost=cost; best=perm; }
        if(!best){ best=perm; bestCost=cost; }
      }
      for(let i=0;i<best.length;i+=2){
        const a=best[i],b=best[i+1]??null;
        if(!a||!b) continue;
        const key=pairKey(a,b); history.set(key,(history.get(key)|0)+1);
      }
      return best;
    }

    function buildRoundsFromFirstRound(first){
      const r0=[];
      for(let i=0;i<first.length;i+=2){
        const p1=first[i]??null, p2=first[i+1]??null;
        r0.push({ p1,p2,winner:autoAdvance(p1,p2), s1:0,s2:0 });
      }
      const rounds=[r0];
      let cur=r0;
      while(cur.length>1){
        const next=[];
        for(let i=0;i<cur.length;i+=2){
          const a=cur[i]?.winner??null, b=cur[i+1]?.winner??null;
          next.push({ p1:a,p2:b,winner:autoAdvance(a,b), s1:0,s2:0 });
        }
        rounds.push(next); cur=next;
      }
      return rounds;
    }

    // ===== L√≥gica de resultado + desempate =====
    function tryScoreDecide(bi,rIdx,mIdx){
      const br=brackets[bi];
      const m=br.rounds[rIdx][mIdx];

      if(!m.p1||!m.p2){
        m.winner=autoAdvance(m.p1,m.p2);
      }else{
        const h1=Math.max(0,parseInt(handicaps[m.p1]??0,10)||0);
        const h2=Math.max(0,parseInt(handicaps[m.p2]??0,10)||0);
        const t1=toInt(m.s1)+h1;
        const t2=toInt(m.s2)+h2;
        if(t1>t2) m.winner=m.p1;
        else if(t2>t1) m.winner=m.p2;
        else{
          if(h1<h2) m.winner=m.p1;
          else if(h2<h1) m.winner=m.p2;
          else{
            // empate total + ventaja -> play-in en siguiente ronda
            m.winner=null;
            if(rIdx<br.rounds.length-1){
              const nextM=br.rounds[rIdx+1][Math.floor(mIdx/2)];
              const side=(mIdx%2===0)?'p1':'p2';
              if(!nextM.tb || nextM.tb.side!==side || !nextM.tb.winner){
                nextM.tb={side,a:m.p1,b:m.p2,sA:0,sB:0,winner:null};
                nextM[side]=null;
                nextM.winner=autoAdvance(nextM.p1,nextM.p2);
              }
            }
          }
        }
      }

      if(rIdx<br.rounds.length-1){
        const nextM=br.rounds[rIdx+1][Math.floor(mIdx/2)];
        const side=(mIdx%2===0)?'p1':'p2';
        if(!nextM.tb || nextM.tb.side!==side || nextM.tb.winner){
          nextM[side]=m.winner;
        }
        finalizeMatchIfReady(br,rIdx+1,Math.floor(mIdx/2));
      }
    }

    function finalizeMatchIfReady(br,rIdx,mIdx){
      const m=br.rounds[rIdx][mIdx];
      if(m.tb && !m.tb.winner){ m.winner=null; return; }
      if(!m.p1||!m.p2){
        m.winner=autoAdvance(m.p1,m.p2);
      }else{
        const h1=Math.max(0,parseInt(handicaps[m.p1]??0,10)||0);
        const h2=Math.max(0,parseInt(handicaps[m.p2]??0,10)||0);
        const t1=toInt(m.s1)+h1;
        const t2=toInt(m.s2)+h2;
        if(t1>t2) m.winner=m.p1;
        else if(t2>t1) m.winner=m.p2;
        else{
          if(h1<h2) m.winner=m.p1;
          else if(h2<h1) m.winner=m.p2;
          else m.winner=null;
        }
      }
      if(rIdx<br.rounds.length-1){
        const nextM=br.rounds[rIdx+1][Math.floor(mIdx/2)];
        const side=(mIdx%2===0)?'p1':'p2';
        if(!nextM.tb || nextM.tb.side!==side || nextM.tb.winner){
          nextM[side]=m.winner;
        }
      }
    }

    function onPickWinner(bi,rIdx,mIdx,player){
      if(!player) return;
      const br=brackets[bi];
      const m=br.rounds[rIdx][mIdx];
      m.winner=player;
      if(rIdx<br.rounds.length-1){
        const nextM=br.rounds[rIdx+1][Math.floor(mIdx/2)];
        const side=(mIdx%2===0)?'p1':'p2';
        if(nextM.tb && nextM.tb.side===side){ nextM.tb.winner=player; nextM.tb=null; }
        nextM[side]=player;
        finalizeMatchIfReady(br,rIdx+1,Math.floor(mIdx/2));
      }
      safeRenderAll();
    }

    // ===== Play-in =====
    function commitTiebreak(bi,rIdx,mIdx){
      const br=brackets[bi];
      const m=br.rounds[rIdx][mIdx]; if(!m.tb) return;
      const {side,a,b,sA,sB}=m.tb;
      const hA=Math.max(0,parseInt(handicaps[a]??0,10)||0);
      const hB=Math.max(0,parseInt(handicaps[b]??0,10)||0);
      const tA=toInt(sA)+hA, tB=toInt(sB)+hB;
      if(tA>tB) m.tb.winner=a;
      else if(tB>tA) m.tb.winner=b;
      else{
        if(hA<hB) m.tb.winner=a;
        else if(hB<hA) m.tb.winner=b;
        else m.tb.winner=null;
      }
      if(m.tb.winner){
        m[side]=m.tb.winner;
        m.tb=null;
        finalizeMatchIfReady(br,rIdx,mIdx);
      }
      safeRenderAll();
    }

    // ===== Selects filtrados R0 =====
    function usedInBracket(bi){
      const set=new Set();
      brackets[bi].rounds[0].forEach(m=>{
        if(m.p1) set.add(canon(m.p1));
        if(m.p2) set.add(canon(m.p2));
      });
      return set;
    }
    function onSelectChange(bi,rIdx,mIdx,pos,value){
      if(value){
        const used=usedInBracket(bi);
        const current=brackets[bi].rounds[rIdx][mIdx][pos];
        const curKey=current?canon(current):null;
        const newKey=canon(value);
        if(newKey!==curKey && used.has(newKey)){ alert('Ese jugador ya est√° asignado en este bracket.'); safeRenderAll(); return; }
      }
      const m=brackets[bi].rounds[rIdx][mIdx];
      m[pos]=value||null;
      m.s1=0; m.s2=0; m.winner=autoAdvance(m.p1,m.p2);
      clearDescendants(bi,rIdx,mIdx);
      safeRenderAll();
    }
    function clearDescendants(bi,rIdx,mIdx){
      const br=brackets[bi];
      for(let r=rIdx+1;r<br.rounds.length;r++){
        const idx=Math.floor(mIdx/(2**(r-rIdx)));
        const mm=br.rounds[r][idx]; if(!mm) break;
        mm.tb=null;
        const pA=br.rounds[r-1][idx*2]?.winner??null;
        const pB=br.rounds[r-1][idx*2+1]?.winner??null;
        mm.p1=pA; mm.p2=pB; mm.s1=0; mm.s2=0; mm.winner=autoAdvance(pA,pB);
      }
    }

    // ===== Render con layout cl√°sico (cajas centradas) + l√≠neas SVG =====
    function titleForRound(rounds,idx){
      const total=rounds.length;
      if(idx===total-1) return "Final";
      if(idx===total-2) return "Semifinal";
      return idx===0?"Cuartos":`Ronda ${idx+1}`;
    }
    function safeRenderAll(){ const y=window.scrollY; renderAll(); window.scrollTo(0,y); }

    function renderAll(){
      const out=document.getElementById('out'); out.innerHTML='';
      brackets.forEach((b,bi)=>{
        const card=document.createElement('div'); card.className='card';
        const head=document.createElement('div'); head.className='btitle';
        head.innerHTML=`<strong>${b.name}</strong><span class="pill">8 cupos</span><span class="hint">Cajas centradas + l√≠neas</span>`;
        card.appendChild(head);

        // wrapper de columnas
        const cols=document.createElement('div');
        cols.style.display='grid';
        cols.style.gridAutoFlow='column';
        cols.style.gridAutoColumns='minmax(440px,1fr)';
        cols.style.gap='12px';
        card.appendChild(cols);

        const totalRounds=b.rounds.length;
        const totalRows=2**totalRounds; // filas discretas para alinear centros

        // Guardaremos refs de cada match para dibujar l√≠neas
        const matchRefs=new Map(); // key: `${r}-${m}`, value: element

        b.rounds.forEach((round,rIdx)=>{
          // columna (grid de filas discretas)
          const col=document.createElement('div');
          col.className='colgrid';
          col.style.gridTemplateRows=`repeat(${totalRows}, 52px)`; // altura por fila
          cols.appendChild(col);

          // t√≠tulo
          const t=document.createElement('div'); t.className='roundtitle'; t.textContent=titleForRound(b.rounds,rIdx);
          // el t√≠tulo ocupa toda la columna arriba
          col.appendChild(t);
          t.style.gridColumn='1';
          t.style.gridRow='1 / span 1';

          // funci√≥n para colocar un match en su fila central
          const centerRow=(r,m)=> (2**r) + m*(2**(r+1)); // 1,3,5,7 | 2,6 | 4 ...
          round.forEach((m,mIdx)=>{
            const box=document.createElement('div');
            box.className='match';
            box.dataset.round=String(rIdx);
            box.dataset.mIdx=String(mIdx);
            // ubicaci√≥n en filas del grid (sumamos +1 por el t√≠tulo que ocupa 1 fila al inicio)
            const row = centerRow(rIdx,mIdx)+1;
            box.style.gridRow=String(row);
            box.style.gridColumn='1';

            const rowUI=(who)=>{
              const wrap=document.createElement('div'); wrap.className='rowPlayer';
              if(rIdx===0){
                const currentVal=m[who]||'';
                const sel=document.createElement('select'); sel.className='sel';
                const optEmpty=document.createElement('option'); optEmpty.value=''; optEmpty.textContent='(BYE)';
                sel.appendChild(optEmpty);
                const used=usedInBracket(bi);
                players.forEach(p=>{
                  const pKey=canon(p);
                  const allow=(pKey===canon(currentVal)) || !used.has(pKey);
                  if(allow){
                    const o=document.createElement('option');
                    o.value=p; o.textContent=`${p}  (+${handicaps[p]??0})`;
                    sel.appendChild(o);
                  }
                });
                sel.value=currentVal;
                sel.onchange=()=>onSelectChange(bi,rIdx,mIdx,who,sel.value);
                wrap.appendChild(sel);
              }else{
                const btn=document.createElement('button'); btn.className='playerBtn';
                const label=m[who]?`${m[who]}  (+${handicaps[m[who]]??0})`:'(BYE)';
                btn.textContent=label;
                if(!m[who]){ btn.classList.add('disabled'); btn.disabled=true; }
                if(m.winner && m.winner===m[who]) btn.classList.add('winner');
                btn.onclick=()=>onPickWinner(bi,rIdx,mIdx,m[who]);
                wrap.appendChild(btn);
              }

              const inp=document.createElement('input');
              const isP1=(who==='p1');
              inp.type='number'; inp.min='0'; inp.step='1'; inp.className='score';
              inp.value=isP1?(m.s1|0):(m.s2|0);
              if(!m[who]){ inp.disabled=true; inp.placeholder='‚Äî'; }
              const total=document.createElement('span'); total.className='totalBadge';
              const updateBadge=()=>{
                const h=m[who]?Math.max(0,parseInt(handicaps[m[who]]??0,10)||0):0;
                const s=m[who]?toInt(inp.value):0;
                total.textContent=`Total: ${s+h}`;
              };
              updateBadge();
              inp.addEventListener('input',()=>{ updateBadge(); });
              const commit=()=>{
                if(isP1) m.s1=toInt(inp.value); else m.s2=toInt(inp.value);
                tryScoreDecide(bi,rIdx,mIdx);
                safeRenderAll();
              };
              inp.addEventListener('change',commit);
              inp.addEventListener('blur',commit);
              inp.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ e.preventDefault(); commit(); } });

              wrap.appendChild(inp); wrap.appendChild(total);
              return wrap;
            };

            box.appendChild(rowUI('p1'));
            box.appendChild(rowUI('p2'));

            if(m.p1 && m.p2 && canon(m.p1)===canon(m.p2)){
              const warn=document.createElement('div'); warn.className='warn'; warn.textContent='‚ö† Auto-enfrentamiento';
              box.appendChild(warn);
            }

            // Play-in (si aplica)
            if(m.tb && !m.tb.winner){
              const tb=document.createElement('div'); tb.className='tbBox';
              const title=document.createElement('div'); title.className='tbTitle';
              title.textContent=`Desempate (play-in) para ${m.tb.side==='p1'?'lado izquierdo':'lado derecho'}:`;
              tb.appendChild(title);

              const rowA=document.createElement('div'); rowA.className='tbRow';
              const lblA=document.createElement('span'); lblA.textContent=`${m.tb.a} (+${handicaps[m.tb.a]??0})`;
              const inA=document.createElement('input'); inA.type='number'; inA.min='0'; inA.step='1'; inA.className='score'; inA.value=m.tb.sA|0;
              const bA=document.createElement('span'); bA.className='tbBadge';
              const updA=()=>{ bA.textContent=`Total: ${toInt(inA.value)+(parseInt(handicaps[m.tb.a]??0,10)||0)}`; };
              inA.addEventListener('input',updA); inA.addEventListener('change',()=>{ m.tb.sA=toInt(inA.value); });
              inA.addEventListener('blur',()=>{ m.tb.sA=toInt(inA.value); });
              updA(); rowA.appendChild(lblA); rowA.appendChild(inA); rowA.appendChild(bA); tb.appendChild(rowA);

              const rowB=document.createElement('div'); rowB.className='tbRow';
              const lblB=document.createElement('span'); lblB.textContent=`${m.tb.b} (+${handicaps[m.tb.b]??0})`;
              const inB=document.createElement('input'); inB.type='number'; inB.min='0'; inB.step='1'; inB.className='score'; inB.value=m.tb.sB|0;
              const bB=document.createElement('span'); bB.className='tbBadge';
              const updB=()=>{ bB.textContent=`Total: ${toInt(inB.value)+(parseInt(handicaps[m.tb.b]??0,10)||0)}`; };
              inB.addEventListener('input',updB); inB.addEventListener('change',()=>{ m.tb.sB=toInt(inB.value); });
              inB.addEventListener('blur',()=>{ m.tb.sB=toInt(inB.value); });
              updB(); rowB.appendChild(lblB); rowB.appendChild(inB); rowB.appendChild(bB); tb.appendChild(rowB);

              const resolve=document.createElement('button'); resolve.className='primary'; resolve.textContent='Resolver play-in';
              resolve.onclick=()=>{ commitTiebreak(bi,rIdx,mIdx); };
              tb.appendChild(resolve);

              box.appendChild(tb);
            }

            col.appendChild(box);
            matchRefs.set(`${rIdx}-${mIdx}`, box);
          });
        });

        // SVG de l√≠neas
        const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
        svg.classList.add('links');
        svg.setAttribute('width','100%');
        svg.setAttribute('height','100%');
        svg.innerHTML=''; // limpiar
        card.appendChild(svg);

        // Dibujar l√≠neas tras pintar DOM
        requestAnimationFrame(()=> drawLinks(svg, matchRefs));
        out.appendChild(card);
      });

      // Redibujar al resize (por si cambia ancho/alto)
      window.onresize=()=>{ document.querySelectorAll('.links').forEach(svg=>{ const card=svg.parentElement; const refs=collectRefs(card); drawLinks(svg, refs); }); };
    }

    // Recolecta refs de un card ya renderizado
    function collectRefs(card){
      const map=new Map();
      card.querySelectorAll('.match').forEach(el=>{
        const r=el.dataset.round, m=el.dataset.mIdx;
        if(r!=null && m!=null) map.set(`${r}-${m}`, el);
      });
      return map;
    }

    // Dibuja l√≠neas entre round r-1 (padres) y r (hijos)
    function drawLinks(svg, refs){
      while(svg.lastChild) svg.removeChild(svg.lastChild);
      // buscamos m√°ximo round
      let maxR=0; refs.forEach((_,k)=>{ const r=parseInt(k.split('-')[0],10); if(r>maxR) maxR=r; });
      const card=svg.parentElement;
      const cardRect=card.getBoundingClientRect();

      for(let r=1; r<=maxR; r++){
        // cu√°ntos matches en este round
        let mIdx=0;
        while(refs.has(`${r}-${mIdx}`)){
          const cur=refs.get(`${r}-${mIdx}`);
          const parA=refs.get(`${r-1}-${mIdx*2}`);
          const parB=refs.get(`${r-1}-${mIdx*2+1}`);
          if(cur && parA && parB){
            const a=centerRight(parA, cardRect);
            const b=centerRight(parB, cardRect);
            const c=centerLeft(cur, cardRect);
            // dos l√≠neas: a->c y b->c
            svg.appendChild(linePath(a.x,a.y,c.x,c.y));
            svg.appendChild(linePath(b.x,b.y,c.x,c.y));
          }
          mIdx++;
        }
      }
    }

    // Helpers para centros relativos al card
    function centerRight(el, parentRect){
      const r=el.getBoundingClientRect();
      return { x: r.right - parentRect.left, y: (r.top+r.bottom)/2 - parentRect.top };
    }
    function centerLeft(el, parentRect){
      const r=el.getBoundingClientRect();
      return { x: r.left - parentRect.left, y: (r.top+r.bottom)/2 - parentRect.top };
    }
    function linePath(x1,y1,x2,y2){
      const ns='http://www.w3.org/2000/svg';
      const path=document.createElementNS(ns,'path');
      // dibujamos con una peque√±a curva (bezier) para elegancia
      const mx=(x1+x2)/2;
      const d=`M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`;
      path.setAttribute('d', d);
      path.setAttribute('fill','none');
      path.setAttribute('stroke','var(--line)');
      path.setAttribute('stroke-width','2');
      return path;
    }

    // ===== Exportar / Importar =====
    document.getElementById('btnExport').onclick=()=>{
      const data={ players,wants,handicaps,pairHistory:Array.from(pairHistory.entries()), brackets };
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download='bowling_brackets.json';
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    };
    document.getElementById('btnImport').onclick=()=>{
      const input=document.createElement('input'); input.type='file'; input.accept='.json,application/json';
      input.onchange=()=>{
        const f=input.files?.[0]; if(!f) return;
        const r=new FileReader();
        r.onload=()=>{
          try{
            const obj=JSON.parse(String(r.result));
            players=obj.players||[];
            wants=obj.wants||{};
            handicaps=obj.handicaps||Object.fromEntries((players||[]).map(n=>[n,0]));
            pairHistory=new Map(obj.pairHistory||[]);
            brackets=obj.brackets||[];
            document.getElementById('names').value=players.map(n=>`${n} (${wants[n]??1})`).join('\n');
            renderConfigTable();
            document.getElementById('configCard').style.display='';
            safeRenderAll();
          }catch(e){ alert('JSON inv√°lido'); }
        };
        r.readAsText(f);
      };
      input.click();
    };
  </script>
  <div style="margin-bottom: 1rem;">
  <button id="btn-bloquear">üîí Bloquear edici√≥n</button>
  <button id="btn-desbloquear">üîì Desbloquear edici√≥n</button>
</div>
  <script>
  function aplicarBloqueo(bloqueado) {
    document.querySelectorAll("input, textarea, select, button:not(#btn-bloquear):not(#btn-desbloquear)").forEach(el => {
      el.disabled = bloqueado;
    });
    localStorage.setItem("modoBloqueado", bloqueado ? "true" : "false");
  }

  // Eventos de los botones
  document.getElementById("btn-bloquear").addEventListener("click", () => aplicarBloqueo(true));
  document.getElementById("btn-desbloquear").addEventListener("click", () => aplicarBloqueo(false));

  // Al cargar la p√°gina, aplicar el bloqueo si estaba activado
  const modoBloqueado = localStorage.getItem("modoBloqueado") === "true";
  aplicarBloqueo(modoBloqueado);
</script>
</body>
</html>


